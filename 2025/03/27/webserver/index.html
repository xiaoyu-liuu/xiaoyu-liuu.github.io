<!DOCTYPE html>
<html lang="en&amp;cn">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Xiao Yu">





<title>webserver | note</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 7.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Xiao Yu&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Xiao Yu&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">webserver</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Xiao Yu</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">March 27, 2025&nbsp;&nbsp;16:25:43</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <h2 id="1-Json"><a href="#1-Json" class="headerlink" title="1.Json"></a>1.Json</h2><p>​	直接将json.hpp放到对应的文件里就行。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;json.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> json = nlohmann::json;</span><br></pre></td></tr></table></figure>

<h2 id="2-muduo"><a href="#2-muduo" class="headerlink" title="2.muduo"></a>2.muduo</h2><p>​	one loop per thread，有一个main reactor负载accept连接，然后把连接分发到某个subreactor（采用round-robin的方式来选择sub reactor），该连接的所用操作都在那个sub reactor所处的线程中完成。多个连接可能被分派到多个线程中，以充分利用CPU。</p>
<p>高并发：</p>
<p>​	首先有个I&#x2F;O线程，里面一个epoll，这是main reactor，主要做新用户的链接。连接后会通过一定的负载算法分发给不同的工作线程，每个工作线程一个epoll，处理已连接用户的读写时间，一般数量会和CPU的核数量相等，尽量做到高并发。IO复用会让一个线程监听多个套接字，链接量大而活跃量少，epoll有大的性能优势。各epoll可以由线程池分配。</p>
<p>一个Base IO thread负责accept新的连接，接收到新的连接以后，使用轮询的方式在reactor pool中找到合适的sub reactor将这个连接挂载上去，这个连接上的所有任务都在这个sub reactor上完成。</p>
<p>如果有过多的耗费CPU I&#x2F;O的计算任务，可以提交到创建的ThreadPool线程池中专门处理耗时的计算任务。（传送文件，音视频等，单独创建线程实现）。</p>
<p>Reactor poll的大小是固定的，根据CPU的数目确定。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置EventLoop的线程个数，底层通过EventLoopThreadPool线程池管理线程类EventLoopThread</span></span><br><span class="line">_server.<span class="built_in">setThreadNum</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>reactor：</p>
<ol>
<li>事件驱动（event handling）</li>
<li>可以处理一个或多个输入源（one or more inputs）</li>
<li>通过Service Handler同步的将输入事件（Event）采用多路复用分发给相应的Request Handler（多个）处理</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// muduo_server.cpp</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">muduo网络库提供了两个主要的类</span></span><br><span class="line"><span class="comment">TcpServer 编写服务器程序</span></span><br><span class="line"><span class="comment">TcpClient 编写客户端程序</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">epoll + 线程池</span></span><br><span class="line"><span class="comment">好处： 能把网络I/O的代码和业务代码区分开</span></span><br><span class="line"><span class="comment">   就关注这两个：用户的链接和断开  用户的可读写事件。</span></span><br><span class="line"><span class="comment">   什么时候发生这两件事情，如何监听这些事情，网络库会上报</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;muduo/net/TcpServer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/EventLoop.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span> <span class="comment">// 绑定器在里面</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo::net;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> placeholders; <span class="comment">// 参数占位符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于muduo网络库开发服务器程序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChatServer</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 3.明确TcpServer构造函数需要什么参数，输出ChatServer的构造函数</span></span><br><span class="line">    <span class="built_in">ChatServer</span>(EventLoop *loop, <span class="comment">// 事件循环</span></span><br><span class="line">            <span class="type">const</span> InetAddress&amp; listenAddr, <span class="comment">// IP+Port</span></span><br><span class="line">            <span class="type">const</span> string&amp; nameArg)     <span class="comment">// 服务器的名字</span></span><br><span class="line">            :_server(loop, listenAddr, nameArg),_loop(loop)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">// 4. 在当前服务器类的构造函数中，注册处理连接的回调函数和处理读写事件的回调函数</span></span><br><span class="line">                </span><br><span class="line">        <span class="comment">// 给服务器注册用户连接的创建和断开回调</span></span><br><span class="line">        _server.<span class="built_in">setConnectionCallback</span>(std::<span class="built_in">bind</span>(&amp;ChatServer::onConnection, <span class="keyword">this</span>, _1));</span><br><span class="line">        <span class="comment">// callback只需要一个参数，而我们的成员方法有俩参数，还有个this呢，而且还有个参数。</span></span><br><span class="line">        <span class="comment">// 通过std::bind将onConnection成员函数绑定到TcpServer的setConnectionCallback。</span></span><br><span class="line">        <span class="comment">//可以使用占位符（如_1、_2等）来表示在实际调用时需要动态传入的参数。</span></span><br><span class="line">        <span class="comment">// this是一个指向当前对象的指针。因为onConnection是一个非静态成员函数，所以需要指定它所属的对象。在这里，this表示当前的ChatServer对象。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 给服务器注册用户读写事件回调</span></span><br><span class="line">        _server.<span class="built_in">setMessageCallback</span>(std::<span class="built_in">bind</span>(&amp;ChatServer::onMessage, <span class="keyword">this</span>, _1, _2, _3));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 设置合适的服务器端的线程数量   1个IO线程，3个worker线程（muduo会自己分配）</span></span><br><span class="line">        _server.<span class="built_in">setThreadNum</span>(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 开启事件循环</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        _server.<span class="built_in">start</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//  专门处理用户的链接和断开</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onConnection</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(conn-&gt;<span class="built_in">connected</span>())&#123;</span><br><span class="line">            cout &lt;&lt; conn-&gt;<span class="built_in">peerAddress</span>().<span class="built_in">toIpPort</span>() &lt;&lt; <span class="string">&quot;-&gt;&quot;</span> &lt;&lt; conn-&gt;<span class="built_in">localAddress</span>().<span class="built_in">toIpPort</span>() &lt;&lt; <span class="string">&quot;state:online&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cout &lt;&lt; conn-&gt;<span class="built_in">peerAddress</span>().<span class="built_in">toIpPort</span>() &lt;&lt; <span class="string">&quot;-&gt;&quot;</span> &lt;&lt; conn-&gt;<span class="built_in">localAddress</span>().<span class="built_in">toIpPort</span>() &lt;&lt; <span class="string">&quot;state:offline&quot;</span> &lt;&lt; endl;</span><br><span class="line">            conn-&gt;<span class="built_in">shutdown</span>(); <span class="comment">// close(fd)</span></span><br><span class="line">            <span class="comment">//_loop-&gt;quit(); // 退出epoll，整个服务器就结束了,就会回收fd资源</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 专门处理用户的读写事件的</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onMessage</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn, <span class="comment">// 连接</span></span></span></span><br><span class="line"><span class="params"><span class="function">                Buffer *buffer,   <span class="comment">// 缓冲区</span></span></span></span><br><span class="line"><span class="params"><span class="function">                Timestamp time)</span>  <span class="comment">// 接收到数据的时间信息</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        string buf = buffer-&gt;<span class="built_in">retrieveAllAsString</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;recv data:&quot;</span> &lt;&lt; buf &lt;&lt; <span class="string">&quot;time:&quot;</span> &lt;&lt; time.<span class="built_in">toString</span>() &lt;&lt; endl;</span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1.第一步组合TcpServer对象</span></span><br><span class="line">    TcpServer _server;</span><br><span class="line">    <span class="comment">// 2.创建Eventlopp事件循环对象的指针,这样就可以在内部操作epoll了。</span></span><br><span class="line">    EventLoop *_loop;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    EventLoop loop;  <span class="comment">// 创建epoll</span></span><br><span class="line">    <span class="function">InetAddress <span class="title">addr</span><span class="params">(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">631</span>)</span></span>;</span><br><span class="line">    <span class="function">ChatServer <span class="title">server</span><span class="params">(&amp;loop, addr, <span class="string">&quot;ChatServer&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    server.<span class="built_in">start</span>(); <span class="comment">// 启动服务  listenfd epoll_ctl  添加到epoll</span></span><br><span class="line">    loop.<span class="built_in">loop</span>(); <span class="comment">// epoll_wait以阻塞方式等待新用户连接，已连接用户的读写事件等</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>运行muduo_server.cpp文件，在terminal中，输入指令：<code>g++ -o server muduo_server.cpp -lmuduo_net -lmuduo_base -lpthread</code>，会生成server可执行文件，然后.&#x2F;server执行即可。</p>
<p>我们再开一个bash的terminal，输入<code>telnet 127.0.0.1 6000</code>，即可连接，此时输入数据就会收到回调。退出的为^]，注意是<code>ctrl+^+]</code>，然后telnet&gt; quit，就关闭了本次连接。</p>
<p>按F1，点击C&#x2F;C++: edit，有c_cpp_properties.json文件。更改配置如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Linux&quot;</span>,</span><br><span class="line">            <span class="comment">// 这里添加编译的搜索路径 </span></span><br><span class="line">            <span class="comment">// gcc  -I头文件搜索路径 -L库文件搜索路径 -l+库的名称 例如 -lmuduo_net</span></span><br><span class="line">            <span class="comment">// user/include  /user/local/lib是默认的，不用加</span></span><br><span class="line">            <span class="string">&quot;includePath&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;defines&quot;</span>: [],</span><br><span class="line">            <span class="string">&quot;compilerPath&quot;</span>: <span class="string">&quot;/usr/bin/gcc&quot;</span>,</span><br><span class="line">            <span class="string">&quot;cStandard&quot;</span>: <span class="string">&quot;c17&quot;</span>,</span><br><span class="line">            <span class="string">&quot;cppStandard&quot;</span>: <span class="string">&quot;gnu++14&quot;</span>,</span><br><span class="line">            <span class="string">&quot;intelliSenseMode&quot;</span>: <span class="string">&quot;linux-gcc-x64&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;version&quot;</span>: <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在运行完一次这个可执行文件后，ctrl+C退出即可，可以直接杀死进程。</p>
<p>如果按到别的ctrl+z等直接退出后，再运行就会显示98错误，即端口被占用。使用<code>lsof -i:6000</code>查看端口占用情况，发现server还在占用这个端口，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COMMAND   PID   USER   FD   TYPE DEVICE SIZE/OFF NODE NAME</span><br><span class="line">server  24342 xiaoyu    6u  IPv4 313192      0t0  TCP localhost:x11 (LISTEN)</span><br></pre></td></tr></table></figure>

<p>这时杀死这个进程就可以了，<code>kill -9 PID</code>，这里是24342。再运行，就会好了。</p>
<h2 id="3-cmake"><a href="#3-cmake" class="headerlink" title="3.cmake"></a>3.cmake</h2><p>先下载cmake，cmake tools插件，whereis cmake 指令找到cmake在unbuntu的位置，然后在cmake tools的setting.json文件中配置<code>&quot;cmake.cmakePath&quot;: &quot;/usr/bin/cmake&quot;,</code>。</p>
<p>编译：可执行文件、 <em>.a静态库、</em>.so动态库</p>
<p><code>g++ -o server（指定可执行文件名称）-g（调试） muduo_server.cpp（编译的源文件） 头文件、库文件的搜索路径（一般有默认不用写，除非特殊的） -lmuduo_net -lmuduo_base -lpthread（要链接的静态库或动态库）</code>这个是编译可执行文件。</p>
<p>在目录下新建CMakeLists.txt文件，编写里面的内容：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)     #指定 cmake最小版本要求为<span class="number">3.0</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">project</span>(main)  #指定项目名称，习惯用大写指定项目名称</span><br><span class="line"></span><br><span class="line"># 配置编译选项</span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_FLAGS $&#123;CMAKE_CXX_FLAGS&#125; -g)</span><br><span class="line"></span><br><span class="line">#配置头文件搜索路径</span><br><span class="line">#<span class="built_in">include_directories</span>()</span><br><span class="line"></span><br><span class="line">#配置库文件搜索路径</span><br><span class="line">#<span class="built_in">link_directories</span>()</span><br><span class="line"></span><br><span class="line"># 设置需要编译的源文件列表</span><br><span class="line"><span class="built_in">set</span>(SRC_LIST muduo_server.cpp)</span><br><span class="line">#把.指定路径下的所有源文件的名字放入变量名SRC_LIST里面</span><br><span class="line">#<span class="built_in">aux_source_directory</span>(. SRC_LIST)</span><br><span class="line"></span><br><span class="line">#表示生成可执行文件server，有SRC_LIST变量所定义的源文件编译而来</span><br><span class="line"><span class="built_in">add_executable</span>(server $&#123;SRC_LIST&#125;)</span><br><span class="line"></span><br><span class="line">#表示server这个目标程序，需要链接这三个库文件</span><br><span class="line"><span class="built_in">target_link_libraries</span>(server muduo_net muduo_base pthread)</span><br></pre></td></tr></table></figure>

<p>在终端处，输入 cmake . 会在当前目录下根据配置的东西进行编译。会得到以下文件：</p>
<p>CMakeCache.txt  cmake_install.cmake  Makefile<br>CMakeFiles      CMakeLists.txt       muduo_server.cpp</p>
<p>然后make生成可执行文件 server。</p>
<p>一般的开源项目编辑时的各目录：（不能把vscode的目录放上去，很不规范）</p>
<p>​	bin:生成的可执行文件</p>
<p>​	lib：中间的库文件</p>
<p>​	include：头文件</p>
<p>​	src：源文件</p>
<p>​	build：编译过程中产生的临时的中间文件</p>
<p>​	example&#x2F;test：示例代码，测试文件</p>
<p>​	thridparty：依赖的第三方库文件</p>
<p>​	CMakeLists.txt  autobuild.sh一键编译</p>
<p>所以下一步，我们将解决规范化生成各文件的位置：</p>
<p>删除当前目录下的所有文件：<code>rm -rf *</code>。</p>
<p>首先在根目录下要创建这些子目录，然后修改CMakeLists.txt文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">----前面的一致</span><br><span class="line"></span><br><span class="line"># 设置需要编译的源文件列表</span><br><span class="line"><span class="built_in">set</span>(SRC_LIST ./muduo_server.cpp)</span><br><span class="line"></span><br><span class="line">#设置可执行文件最终存储的路径（新增）</span><br><span class="line"><span class="built_in">set</span>(EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/bin)  #PROJECT_SOURCE_DIR 工程根目录</span><br><span class="line"></span><br><span class="line">#把.指定路径下的所有源文件的名字放入变量名SRC_LIST里面</span><br><span class="line">#<span class="built_in">aux_source_directory</span>(. SRC_LIST)</span><br><span class="line"></span><br><span class="line">#表示生成可执行文件server，有SRC_LIST变量所定义的源文件编译而来</span><br><span class="line"><span class="built_in">add_executable</span>(server $&#123;SRC_LIST&#125;)</span><br><span class="line"></span><br><span class="line">#表示server这个目标程序，需要链接这三个库文件</span><br><span class="line"><span class="built_in">target_link_libraries</span>(server muduo_net muduo_base pthread)</span><br></pre></td></tr></table></figure>

<p>进入build目录下，输入cmake ..（因为CMakeLists.txt文件在上一层文件里），就会将生成的cmake相关的文件放到&#x2F;build里。然后再make。</p>
<h2 id="4-Mysql"><a href="#4-Mysql" class="headerlink" title="4.Mysql"></a>4.Mysql</h2><p><code>mysql -u root -p</code>打开数据库，输入密码“123456”，</p>
<p>可以用<code>sudo netstat -tanp</code>，这个指令查看mysql是否活跃状态。</p>
<p><code>show databases;</code>可以查看现有的数据库。</p>
<p><code>create database if not exists chat;</code>创建一个名为chat的数据库。</p>
<p><code>use chat;</code>打开此数据库。</p>
<p><code>show tables;</code>查看里面的表</p>
<p>新建表格：</p>
<p><strong>User表</strong></p>
<table>
<thead>
<tr>
<th>字段名称</th>
<th>字段类型</th>
<th>字段说明</th>
<th>约束</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>INT</td>
<td>用户id</td>
<td>PRIMARY KEY, AUTO_INCREMENT</td>
</tr>
<tr>
<td>name</td>
<td>VARCHAR(50)</td>
<td>用户名</td>
<td>NOT NULL, UNIQUE</td>
</tr>
<tr>
<td>password</td>
<td>VARCHAR(50)</td>
<td>用户密码</td>
<td>NOT NULL</td>
</tr>
<tr>
<td>state</td>
<td>ENUM(‘online’, ‘offline’)</td>
<td>当前登录状态</td>
<td>DEFAULT ‘offline’</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE User (</span><br><span class="line">    -&gt; id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">    -&gt; name VARCHAR(50) NOT NULL UNIQUE,</span><br><span class="line">    -&gt; password VARCHAR(50) NOT NULL,</span><br><span class="line">    -&gt; state ENUM(&#x27;online&#x27;, &#x27;offline&#x27;) DEFAULT &#x27;offline&#x27;</span><br><span class="line">    -&gt; )</span><br><span class="line">    -&gt; CHARACTER SET utf8mb4;</span><br></pre></td></tr></table></figure>

<p><strong>Friend表</strong></p>
<table>
<thead>
<tr>
<th>字段名称</th>
<th>字段类型</th>
<th>字段说明</th>
<th>约束</th>
</tr>
</thead>
<tbody><tr>
<td>userid</td>
<td>INT</td>
<td>用户id</td>
<td>NOT NULL、联合主键</td>
</tr>
<tr>
<td>friendid</td>
<td>INT</td>
<td>好友id</td>
<td>NOT NULL、联合主键</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE Friend (</span><br><span class="line">    -&gt; userid INT NOT NULL,</span><br><span class="line">    -&gt; friendid INT NOT NULL,</span><br><span class="line">    -&gt; PRIMARY KEY (userid, friendid),</span><br><span class="line">    -&gt; FOREIGN KEY (userid) REFERENCES User(id) ON DELETE CASCADE,</span><br><span class="line">    -&gt; FOREIGN KEY (friendid) REFERENCES User(id) ON DELETE CASCADE</span><br><span class="line">    -&gt; )</span><br><span class="line">    -&gt; CHARACTER SET utf8mb4;  </span><br></pre></td></tr></table></figure>

<p><strong>AllGroup表</strong></p>
<table>
<thead>
<tr>
<th>字段名称</th>
<th>字段类型</th>
<th>字段说明</th>
<th>约束</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>INT</td>
<td>组id</td>
<td>PRIMARY KEY、AUTO_INCREMENT</td>
</tr>
<tr>
<td>groupname</td>
<td>VARCHAR(50)</td>
<td>组名称</td>
<td>NOT NULL, UNIQUE</td>
</tr>
<tr>
<td>groupdesc</td>
<td>VARCHAR(200)</td>
<td>组功能描述</td>
<td>DEFAULT ‘’</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE AllGroup (</span><br><span class="line">    -&gt; id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">    -&gt; groupname VARCHAR(50) NOT NULL UNIQUE,</span><br><span class="line">    -&gt; groupdesc VARCHAR(200) DEFAULT &#x27;&#x27;</span><br><span class="line">    -&gt; )</span><br><span class="line">    -&gt; CHARACTER SET utf8mb4;</span><br></pre></td></tr></table></figure>

<p><strong>GroupUser表</strong></p>
<table>
<thead>
<tr>
<th>字段名称</th>
<th>字段类型</th>
<th>字段说明</th>
<th>约束</th>
</tr>
</thead>
<tbody><tr>
<td>groupid</td>
<td>INT</td>
<td>组id</td>
<td>NOT NULL、联合主键</td>
</tr>
<tr>
<td>userid</td>
<td>INT</td>
<td>组员id</td>
<td>NOT NULL、联合主键</td>
</tr>
<tr>
<td>grouprole</td>
<td>ENUM(‘creator’, ‘normal’)</td>
<td>组内角色</td>
<td>DEFAULT ‘normal’</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE GroupUser (</span><br><span class="line">    -&gt; groupid INT NOT NULL,</span><br><span class="line">    -&gt; userid INT NOT NULL,</span><br><span class="line">    -&gt; grouprole ENUM(&#x27;creator&#x27;, &#x27;normal&#x27;) NOT NULL DEFAULT &#x27;normal&#x27;,</span><br><span class="line">    -&gt; PRIMARY KEY (groupid, userid),</span><br><span class="line">    -&gt; FOREIGN KEY (groupid) REFERENCES AllGroup(id) ON DELETE CASCADE,</span><br><span class="line">    -&gt; FOREIGN KEY (userid) REFERENCES User(id) ON DELETE CASCADE</span><br><span class="line">    -&gt; )</span><br><span class="line">    -&gt; CHARACTER SET utf8mb4;</span><br></pre></td></tr></table></figure>

<p><strong>OfflineMessage表</strong></p>
<table>
<thead>
<tr>
<th>字段名称</th>
<th>字段类型</th>
<th>字段说明</th>
<th>约束</th>
</tr>
</thead>
<tbody><tr>
<td>userid</td>
<td>INT</td>
<td>用户id</td>
<td>NOT NULL</td>
</tr>
<tr>
<td>message</td>
<td>VARCHAR(50)</td>
<td>离线消息（存储Json字符串）</td>
<td>NOT NULL</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE OfflineMessage (</span><br><span class="line">    -&gt; userid INT NOT NULL,</span><br><span class="line">    -&gt; message VARCHAR(50) NOT NULL,</span><br><span class="line">    -&gt; PRIMARY KEY (userid)</span><br><span class="line">    -&gt; )</span><br><span class="line">    -&gt; CHARACTER SET utf8mb4;</span><br></pre></td></tr></table></figure>

<h2 id="5-项目实施"><a href="#5-项目实施" class="headerlink" title="5.项目实施"></a>5.项目实施</h2><h3 id="5-1-框架搭建以及cmake文件编写"><a href="#5-1-框架搭建以及cmake文件编写" class="headerlink" title="5.1 框架搭建以及cmake文件编写"></a>5.1 框架搭建以及cmake文件编写</h3><p>首先按照规范建立bin、build、include、src、thirdparty等目录。在根目录下编写cmakelists文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.0)     #指定 cmake最小版本要求为3.0</span><br><span class="line"> </span><br><span class="line">project(chat)  #指定项目名称，习惯用大写指定项目名称</span><br><span class="line"></span><br><span class="line"># 配置编译选项</span><br><span class="line">set(CMAKE_CXX_FLAGS $&#123;CMAKE_CXX_FLAGS&#125; -g)</span><br><span class="line"></span><br><span class="line">#配置最终的可执行文件输出的路径</span><br><span class="line">set(EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/bin)  #PROJECT_SOURCE_DIR 工程根目录</span><br><span class="line"></span><br><span class="line">#配置头文件搜索路径</span><br><span class="line">include_directories($&#123;PROJECT_SOURCE_DIR&#125;/include)</span><br><span class="line">include_directories($&#123;PROJECT_SOURCE_DIR&#125;/include/server)</span><br><span class="line"></span><br><span class="line">#加载子目录(源码都在src中)</span><br><span class="line">add_subdirectory(src)</span><br></pre></td></tr></table></figure>

<p>然后进入源码目录src，编写此处的cmake文件：(src里面有两个子目录，一个server，一个client，这里先只考虑server)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_subdirectory(server)</span><br></pre></td></tr></table></figure>

<p>再进入server目录下，编写此处最终的cmake文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#定义了一个SRC_LIST变量，包含了该目录底下所有的源文件</span><br><span class="line">aux_source_directory(. SRC_LIST)</span><br><span class="line"></span><br><span class="line">#指定生成可执行文件</span><br><span class="line">add_executable(ChatServer $&#123;SRC_LIST&#125;)</span><br><span class="line"></span><br><span class="line"># 指定可执行文件链接时需要依赖的库文件</span><br><span class="line">target_link_libraries(ChatServer muduo_net muduo_base pthread)</span><br></pre></td></tr></table></figure>

<p>后续会随着其他第三方库或者其他头文件的加入从而完善我们的CMakeLists.txt。</p>
<h3 id="5-2-网络模块ChatServer代码编写"><a href="#5-2-网络模块ChatServer代码编写" class="headerlink" title="5.2 网络模块ChatServer代码编写"></a>5.2 网络模块ChatServer代码编写</h3><p>首先在.&#x2F;include&#x2F;server下建立chatserver.hpp头文件。在里面对ChatServer类进行声明。这是聊天服务器的主类。</p>
<p>利用构造函数初始化其对象，并添加启动服务的开启循环的函数，以及关于上报连接相关信息和读写事件相关信息的回调函数。</p>
<p>其成员数据包括<code>TcpServer _server; EventLoop *_loop; </code>去实现服务器功能和指向循环对象的指针。</p>
<p>muduo 使用 TcpConnection 封装一次 TCP 连接，这也是我们用户编程会直接交互的类。而 TcpServer 用于编写网络服务器，接收客户端发起连接。我们将利用 TcpServer 这个类来构造我们的聊天服务器 ChatServer。</p>
<p>然后创建chatserver.cpp文件，实现具体功能：</p>
<p>针对不同的事件，TcpServer 保存着不同事件发生时要调用的「回调函数」。我们就要通过向 TcpServer 注册不同的回调函数来完成我们的业务逻辑。比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上报连接相关信息的回调函数（新连接到来/旧连接断开）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChatServer::onConnection</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 客户端断开链接或连接失败（有用户下线）  要释放资源</span></span><br><span class="line">    <span class="keyword">if</span> (!conn-&gt;<span class="built_in">connected</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        conn-&gt;<span class="built_in">shutdown</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 ChatServer 接收到连接相关事件时，会调用我们写的<code>ChatServer::onConnection</code>函数。如果是客户端连接断开的事件，我们会关闭连接。</p>
<p>我们还需要处理消息到来的事件，放到项目中可能是不同类型的消息。比如，好友之间的个人聊天消息，群组之间的广播消息，登录信息和注册信息。这就需要处理读写事件的相关信息的回调函数，我们首先从缓冲区中取出字符串，然后利用json反序列化，从接收到的信息中就会有一个messageID，根据此ID进行业务处理。针对不同的信息，我们会用不同的字段messageID来标识，而我们在 muduo 中接收到了不同的信息，肯定也会调用不同的处理函数。</p>
<p>这时如果在网络模块中书写业务模块的代码，会显得逻辑不好，希望实现一个统一的调用，对于任何业务都调用一个方法就行，然后这个函数会有着不同的实现。因此，我们还会创建一个 <code>ChatService</code> 类来专门提供不同的「服务」，<code>ChatService</code>使用<code>function</code>容易保存不同的回调函数，我们使用 Json 解析数据时得到数据类型，然后直接调用对应的函数（这些回调函数最开始已经被注册过了）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上报读写事件相关信息的回调函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChatServer::onMessage</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn,</span></span></span><br><span class="line"><span class="params"><span class="function">               Buffer *buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">               Timestamp time)</span>  <span class="comment">///收到消息了</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string buf = buffer-&gt;<span class="built_in">retrieveAllAsString</span>();<span class="comment">// 从缓冲区拿到字符串里面</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据的反序列化（解码） 会包含一个messageID</span></span><br><span class="line">    json js = json::<span class="built_in">parse</span>(buf);</span><br><span class="line">    <span class="comment">// 达到的目的：完全解耦网络模块的代码和业务模块的代码</span></span><br><span class="line">    <span class="comment">// 通过js[&quot;msgid&quot;]获取=》业务处理器handler</span></span><br><span class="line">    <span class="keyword">auto</span> msgHandler = ChatService::<span class="built_in">instance</span>()-&gt;<span class="built_in">getHandler</span>(js[<span class="string">&quot;msgid&quot;</span>].<span class="built_in">get</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    <span class="comment">// 回调消息绑定好的事件处理器，来执行相应的业务处理</span></span><br><span class="line">    <span class="built_in">msgHandler</span>(conn, js, time);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-3-业务模块chatservice代码编写"><a href="#5-3-业务模块chatservice代码编写" class="headerlink" title="5.3 业务模块chatservice代码编写"></a>5.3 业务模块chatservice代码编写</h3><p>ChatServiec 负责解耦业务模块和网络模块，其内部保存了各个业务模块的<code>handler</code>（业务函数）。考虑其<code>ChatService</code>的唯一性，我们使用<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%8D%95%E4%BE%8B&spm=1001.2101.3001.7020">单例</a>模式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Class ChatService</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// ChatService 单例模式</span></span><br><span class="line">	<span class="comment">// thread safe</span></span><br><span class="line">	<span class="function"><span class="type">static</span> ChatService* <span class="title">instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// C++11保证静态局部对象是线程安全的</span></span><br><span class="line">		<span class="type">static</span> ChatService service;</span><br><span class="line">		<span class="keyword">return</span> &amp;service;</span><br><span class="line">	&#125;</span><br><span class="line">	/....../</span><br><span class="line">		</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">ChatService</span>();</span><br><span class="line">    <span class="built_in">ChatService</span>(<span class="type">const</span> ChatService&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    ChatService&amp; <span class="keyword">operator</span>=(<span class="type">const</span> ChatService&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>1、ChatService()构造函数被私有化，外界只能调用ChatService的静态方法。<br>2、类中的static变量会保证全局唯一，多个实例共享一个static变量，如果该static变量已经初始化过了，不会再次初始化。static修饰过的成员变量和方法独立于类的任何对象。正是运用此性质，每次只得到之前已经初始化后的static变量。<br>3、C++ 11 保证 static 成员变量是线程安全的。</p>
<p>解耦各个模块的核心就是getHandler()函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> MsgHandler = std::function&lt;<span class="built_in">void</span>(<span class="type">const</span> TcpConnectionPtr &amp;conn, json &amp;js, Timestamp)&gt;;</span><br><span class="line"><span class="comment">//在类中：</span></span><br><span class="line"><span class="comment">// 获取消息对应的处理器</span></span><br><span class="line"><span class="function">MsgHandler <span class="title">getHandler</span><span class="params">(<span class="type">int</span> msgid)</span></span>;</span><br></pre></td></tr></table></figure>

<p>ChatService 提前将各个业务模块的代码放入了function容器中，其内部有用哈希表记录了各种msgid所对应的MsgHandler（业务处理函数）。因此每次接收消息时，通过getHandler(msgid)得到对应的业务处理函数，再统一用msgHandler(conn, js, time);来调用。某种角度上，getHandler有点智能路由的意思。</p>
<p>在构造函数内部就在哈希表中记录了 （消息类型 -&gt; 绑定的回调函数）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册消息以及对应的Handler回调操作</span></span><br><span class="line">ChatService::<span class="built_in">ChatService</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 用户基本业务管理相关事件处理回调注册</span></span><br><span class="line">    _msgHandlerMap.<span class="built_in">insert</span>(&#123;LOGIN_MSG, std::<span class="built_in">bind</span>(&amp;ChatService::login, <span class="keyword">this</span>, _1, _2, _3)&#125;);</span><br><span class="line">    _msgHandlerMap.<span class="built_in">insert</span>(&#123;REG_MSG, std::<span class="built_in">bind</span>(&amp;ChatService::reg, <span class="keyword">this</span>, _1, _2, _3)&#125;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此可以通过<code>getHandler(int msgId)</code>获取函数，如果找不到改情况的理器，会返回一个默认的处理器。这里直接使用 lambda 表达式打印日志。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取消息对应的处理器</span></span><br><span class="line"><span class="function">MsgHandler <span class="title">ChatService::getHandler</span><span class="params">(<span class="type">int</span> msgid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 记录错误日志，msgid没有对应的事件处理回调</span></span><br><span class="line">    <span class="keyword">auto</span> it = _msgHandlerMap.<span class="built_in">find</span>(msgid);</span><br><span class="line">    <span class="keyword">if</span> (it == _msgHandlerMap.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 返回一个默认的处理器，空操作(直接用muduo的打印就行)</span></span><br><span class="line">        <span class="keyword">return</span> [=](<span class="type">const</span> TcpConnectionPtr &amp;conn, json &amp;js, Timestamp) &#123;</span><br><span class="line">            LOG_ERROR &lt;&lt; <span class="string">&quot;msgid:&quot;</span> &lt;&lt; msgid &lt;&lt; <span class="string">&quot; can not find handler!&quot;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> _msgHandlerMap[msgid];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至于消息类型的定义，在include目录下的public.hpp文件中声明，利用枚举类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">EnMsgType</span></span><br><span class="line">&#123;</span><br><span class="line">    LOGIN_MSG = <span class="number">1</span>, <span class="comment">// 登录消息</span></span><br><span class="line">    REG_MSG, <span class="comment">// 注册消息</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>后续增加功能就在对应的文件里面添加即可。</p>
<h3 id="5-4-MySQL数据库代码封装"><a href="#5-4-MySQL数据库代码封装" class="headerlink" title="5.4 MySQL数据库代码封装"></a>5.4 MySQL数据库代码封装</h3><p>前面我们已经将网络模块和业务模块通过回调函数进行了解耦。这是我们要考虑将业务模块和数据模块也进行解耦。ORM框架，对象关系映射，业务层操作的都是对象，数据层才是具体的数据库的操作。不要在业务模块出现增删改查的操作。</p>
<p>我们在头文件和源文件的server下分别建立db.hpp和dp.cpp，用于数据库代码的编写。同时CMakeLists.txt得做出相应的补充。又因为我们使用了mysql第三方库，所以在里面还得加mysqlclient。</p>
<p>我们增加一个mysql类，在构造函数中初始化一个与<code>mysql_real_connect()</code>相适应的<code>MYSQL</code>对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MYSQL* <span class="title">mysql_init</span><span class="params">(MYSQL* mysql)</span> 即：_conn </span>= <span class="built_in">mysql_init</span>(<span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure>

<p>连接数据库时，因为mysql_real_connect要求的格式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MYSQL *<span class="title">mysql_real_connect</span><span class="params">(MYSQL *mysql, <span class="type">const</span> <span class="type">char</span> *host, <span class="type">const</span> <span class="type">char</span> *user, <span class="type">const</span> <span class="type">char</span> *passwd, <span class="type">const</span> <span class="type">char</span> *db, <span class="type">unsigned</span> <span class="type">int</span> port, <span class="type">const</span> <span class="type">char</span> *unix_socket, <span class="type">unsigned</span> <span class="type">long</span> clientflag)</span></span></span><br></pre></td></tr></table></figure>

<p>而我们代码传入的是string类型的数据，所以我们使用string内部的.c_str()函数，其返回的指针指向 std::string 对象内部的字符数组，即const char *类型。因此，只要 std::string 对象存在，这个指针就有效，且满足MTSQL对象的格式要求。</p>
<p>将我们规定的地址和用户及密码等传入此函数，创建一个新连接成功的话，会返回一个非空的 <code>MYSQL*</code> 指针。失败时，返回 <code>nullptr</code>。</p>
<p>所以在connect成员函数中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">MYSQL *p = <span class="built_in">mysql_real_connect</span>(_conn, server.<span class="built_in">c_str</span>(), user.<span class="built_in">c_str</span>(),</span><br><span class="line">                                  password.<span class="built_in">c_str</span>(), dbname.<span class="built_in">c_str</span>(), <span class="number">3306</span>, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// C和C++代码默认的编码字符是ASCII，如果不设置，从MySQL上拉下来的中文显示？</span></span><br><span class="line">   <span class="comment">// 如果连接成功，它将设置字符集为 gbk 以支持中文字符，并记录一条成功日志。</span></span><br><span class="line">   <span class="built_in">mysql_query</span>(_conn, <span class="string">&quot;set names gbk&quot;</span>);</span><br><span class="line">   LOG_INFO &lt;&lt; <span class="string">&quot;connect mysql success!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 如果连接失败，它将记录一条失败日志。</span></span><br><span class="line">   LOG_INFO &lt;&lt; <span class="string">&quot;connect mysql fail!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数返回一个布尔值，指示连接是否成功。</span></span><br><span class="line"><span class="keyword">return</span> p;</span><br></pre></td></tr></table></figure>

<p>对于更新和查询等操作，其目的是执行一个 SQL 操作，传入的<code>string sql</code>就包含了要执行的 SQL 更新语句。只不过也得：<code>mysql_query(_conn, sql.c_str())</code>，调用了 <code>mysql_query</code> 函数，这是 MySQL C API 的一部分，用于执行传入的 SQL 语句。函数会返回一个 <code>bool</code> 类型，表示更新操作是否成功。</p>
<h3 id="5-5-Model数据层代码编写"><a href="#5-5-Model数据层代码编写" class="headerlink" title="5.5 Model数据层代码编写"></a>5.5 Model数据层代码编写</h3><p>对应着前面MYSQL里的各个表，创建对应的各种类。（还是在server目录下的model里面添加）</p>
<h3 id="5-6-用户登录注册等代码编写"><a href="#5-6-用户登录注册等代码编写" class="headerlink" title="5.6 用户登录注册等代码编写"></a>5.6 用户登录注册等代码编写</h3><p>在用户注册模块，由<code>ChatService::reg</code>函数处理业务。</p>
<p>我们从传递过来的json对象中获取用户 ID 和用户密码。并用此信息初始化一个User对象，其初始状态设置为offline。<br>之后调用 model 层代码与数据库交互，插入这个用户的信息。若成功则发出response信息，记得需要将信息序列化，<code>conn-&gt;send(response.dump());</code>。</p>
<p>在用户登录模块，由<code>ChatService::log</code>函数处理业务。</p>
<p>从<code>json</code>对象中获取用户ID和密码，并在数据库中查询获取用户信息。如果用户已经登录过，即<code>state == &quot;online&quot;</code>，则返回错误信息。登录成功后，需要在用户表<code>_userConnMap&lt;ID, TcpConnection&gt;</code>中记录新登录的用户。<strong>考虑到多线程对此<code>map</code>进行操作，我们需要使用互斥锁。<code>lock_guard</code>遵守<code>RALL</code>手法，初始化即上锁，销毁即解锁。这里用临时作用域让锁得颗粒度变小，保证性能。</strong></p>
<h3 id="5-7-客户端异常退出事件"><a href="#5-7-客户端异常退出事件" class="headerlink" title="5.7 客户端异常退出事件"></a>5.7 客户端异常退出事件</h3><p>如果客户端异常退出了，我们会从服务端记录用户连接的 <code>_connMap</code> 表中找到该用户，如果它断连了就从此表中删除，并设置其状态为 <code>offline</code>。<strong>因为记录用户连接情况的表是可能被多个线程操作的，所以访问表的操作都要使用互斥锁进行保护。</strong></p>
<h3 id="5-8-点对点聊天业务处理"><a href="#5-8-点对点聊天业务处理" class="headerlink" title="5.8 点对点聊天业务处理"></a>5.8 点对点聊天业务处理</h3><p>通过 JSON 对象的 <code>toid</code>找寻对话用户  <code>int toId = js[&quot;toid&quot;].get&lt;int&gt;();</code></p>
<ul>
<li>用户处于登录状态：直接向该用户发送信息</li>
<li>用户处于离线状态：需存储离线消息</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChatService::oneChatHandler</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn, json &amp;js, Timestamp time)</span></span></span><br></pre></td></tr></table></figure>

<p>注意这里也得考虑线程安全。</p>
<p>登陆之后就可以输入{“msgid”:5,”id”:5,”from”:”zhaozhao”,”toid”:4,”msg”:”hello!”}发送消息，同时对方也收到</p>
<h3 id="5-9-离线消息业务代码"><a href="#5-9-离线消息业务代码" class="headerlink" title="5.9 离线消息业务代码"></a>5.9 离线消息业务代码</h3><p>在model层创建类，提供离线消息表的操作接口方法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OfflineMsgModel</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 存储用户的离线消息</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> userId, std::string msg)</span></span>;</span><br><span class="line">    <span class="comment">// 删除用户的离线消息</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> userId)</span></span>;</span><br><span class="line">    <span class="comment">// 查询用户的离线消息</span></span><br><span class="line">    <span class="function">std::vector&lt;std::string&gt; <span class="title">query</span><span class="params">(<span class="type">int</span> userId)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>并写cpp文件实现其中的类。然后到ChatService.hpp中去实例化一个对象<code>OfflineMsgModel _offlineMsgModel</code>。在ChatService.cpp中去利用对象实现离线信息的相关操作。</p>
<h3 id="5-10-服务端异常处理"><a href="#5-10-服务端异常处理" class="headerlink" title="5.10 服务端异常处理"></a>5.10 服务端异常处理</h3><p>之前讲解了客户端异常退出的代码，但是服务端也是会异常退出的。如果服务端异常退出，它会将所有在线的客户的状态都设置为<code>offline</code>。即，让所有用户都下线。<br>异常退出一般是<code>CTRL + C</code>时，我们需要捕捉信号。这里使用了 Linux 的信号处理函数，我们向信号注册回调函数。</p>
<p>在main函数中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 捕获SIGINT的处理函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resetHandler</span><span class="params">(<span class="type">int</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LOG_INFO &lt;&lt; <span class="string">&quot;capture the SIGINT, will reset state\n&quot;</span>;</span><br><span class="line">    ChatService::<span class="built_in">instance</span>()-&gt;<span class="built_in">reset</span>();</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向SIGINT信号注册resetHandler回调函数</span></span><br><span class="line"><span class="built_in">signal</span>(SIGINT, resetHandler);</span><br></pre></td></tr></table></figure>

<p>然后在ChatService::reset()实现此方法。会调用<code> _userModel.resetState();</code>，将用户状态改变。</p>
<h3 id="5-11-添加好友业务"><a href="#5-11-添加好友业务" class="headerlink" title="5.11 添加好友业务"></a>5.11 添加好友业务</h3><p>首先建立friendmodel类，提供向数据库db层好友表的接口，有着添加好友关系和返回好友列表两个方法。</p>
<p>在实现这些成员函数时，注意其好友列表返回的是个<code>vector&lt;user&gt;</code>。</p>
<p>然后在ChatService.hpp中去实例化一个对象，并在cpp函数中，添加代码，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChatService::addFriendHandler</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn, json &amp;js, Timestamp time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> userId = js[<span class="string">&quot;id&quot;</span>].<span class="built_in">get</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">    <span class="type">int</span> friendId = js[<span class="string">&quot;friendid&quot;</span>].<span class="built_in">get</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储好友信息</span></span><br><span class="line">    _friendModel.<span class="built_in">insert</span>(userId, friendId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并在构造函数中进行回调的注册。</p>
<p>查询好友列表，在登录处理中进行。我们登录一个账号，会相应的显示其好友情况。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询该用户的好友信息并返回</span></span><br><span class="line">vector&lt;User&gt; userVec = _friendModel.<span class="built_in">query</span>(id);</span><br><span class="line"><span class="keyword">if</span> (!userVec.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">   vector&lt;string&gt; vec2;</span><br><span class="line">   <span class="keyword">for</span> (User &amp;user : userVec)</span><br><span class="line">   &#123;</span><br><span class="line">       json js;</span><br><span class="line">       js[<span class="string">&quot;id&quot;</span>] = user.<span class="built_in">getId</span>();</span><br><span class="line">       js[<span class="string">&quot;name&quot;</span>] = user.<span class="built_in">getName</span>();</span><br><span class="line">       js[<span class="string">&quot;state&quot;</span>] = user.<span class="built_in">getState</span>();</span><br><span class="line">       vec<span class="number">2.</span><span class="built_in">push_back</span>(js.<span class="built_in">dump</span>());</span><br><span class="line">   &#125;</span><br><span class="line">   response[<span class="string">&quot;friends&quot;</span>] = vec2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Xiao Yu</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="http://xiaoyu-liuu.github.io/2025/03/27/webserver/">http://xiaoyu-liuu.github.io/2025/03/27/webserver/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY</strong>?</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
            
            <a class="next" rel="next" href="/2025/03/21/primerC/">primerC</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Xiao Yu | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>